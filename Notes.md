# Project Roadmap 
## Creating an ASP.NET Core API

## Getting Started...
1. Create a project directory: `$ mkdir ParksApi.Solution`
2. Navigate to project directory: `$ cd ParksApi.Solution`
3. Use `dotnet new` to scaffold project: `$ dotnet new webapi -o ParksApi  --framework net6.0`
4. Create README and .gitignore: `$ touch README.md .gitignore`
5. Complete `.gitignore` and add list of directories and files git should ignore.
    <details><summary><code>ParksApi.Solution/.gitignore</code></summary> 

    ```
    bin
    obj
    appsettings.json
    ```
    </details>
6. Initialize Git: `$ git init`

7. Make first commit for `.gitignore` so that Git doesn't track unwanted files.
    - `$ git add .gitignore` 
    - `$ git commit -m "add .gitignore"` 

8. Disable nullable context for the entire project:
    <details><summary><code>ParksApi.csproj</code></summary> 

    ```c#
    <Project Sdk="Microsoft.NET.Sdk.Web">

      <PropertyGroup>
        <TargetFramework>net6.0</TargetFramework>
        // comment-out the line below to disable nullable context
        // Note that we can still create a nullable context where 
        // necessary with a directive: #nullable enable
        <!-- <Nullable>enable</Nullable> -->
        <ImplicitUsings>enable</ImplicitUsings>
      </PropertyGroup>

      <ItemGroup>
        <PackageReference Include="Swashbuckle.AspNetCore" Version="6.    2.3" />
      </ItemGroup>

    </Project>
    ```
    </details>

9. Update appsetting.Development.json:
    <details><summary><code>appsettings.Development.json</code></summary> 

    ```json
    {
      "Logging": {
        "LogLevel": {
          "Default": "Information",
          "Microsoft": "Trace",
          "Microsoft.AspNetCore": "Information",
          "Microsoft.Hosting.Lifetime": "Information"
        }
      }
    }
    ```
    </details>

10. Build a Host for the Web API in Program.cs:
    <details><summary><code>Program.cs</code></summary> 

    ```c#
    var builder = WebApplication.CreateBuilder(args);

    // Add services to the container.
    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();

    var app = builder.Build();

    // Configure the HTTP request pipeline.
    if (app.Environment.IsDevelopment())
    {
      app.UseSwagger();
      app.UseSwaggerUI();
    }
    else 
    {
      app.UseHttpsRedirection();
    }

    app.UseAuthorization();

    app.MapControllers();

    app.Run();
    ```
    </details>
11. Update launchSettings.json:
    <details><summary><code>Properties/launchSettings.json</code></summary> 

    ```json
    {
      "$schema": "https://json.schemastore.org/launchsettings.json",
      "iisSettings": {
        "windowsAuthentication": false,
        "anonymousAuthentication": true,
        "iisExpress": {
          "applicationUrl": "http://localhost:4725",
          "sslPort": 44346
        }
      },
      "profiles": {
        "CretaceousApi": {
          "commandName": "Project",
          "dotnetRunMessages": true,
          "launchBrowser": true,
          "launchUrl": "swagger",
          "applicationUrl": "https://localhost:5001;http://localhost:5000",
          "environmentVariables": {
            "ASPNETCORE_ENVIRONMENT": "Development"
          }
        }
      },
      "IIS Express": {
        "commandName": "IISExpress",
        "launchBrowser": true,
        "launchUrl": "swagger",
        "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }
      }
    }
    ```
    </details>

12. Run the app with `$ dotnet run` and visit `https://localhost:5000/swagger` in a browser to confirm that app is properly configured. The swagger page should indicate that your app is ready to recieve GET requests for the boilerplate WeatherForecast app that was generated by the `dotnet new` command.

13. Remove boilerplate WeatherForecast files: 
    ```
    $ rm WeatherForecast.cs 
    $ rm Controllers/WeatherForecastController.cs
    ```

14. Add the necessary packages for Entity Framework Core and migrations
    ```
    $ dotnet add package Microsoft.EntityFrameworkCore -v 6.0.0
    $ dotnet add package Pomelo.EntityFrameworkCore.MySql -v 6.0.0
    $ dotnet add package Microsoft.EntityFrameworkCore.Design -v 6.0.0
    ```

    - After adding the packages above your `.csproj` should look like this:

      <details><summary><code>ParksApi/ParksApi.csproj</code></summary> 

      ```c#
      <Project Sdk="Microsoft.NET.Sdk.Web">

        <PropertyGroup>
          <TargetFramework>net6.0</TargetFramework>
          <!-- <Nullable>enable</Nullable> -->
          <ImplicitUsings>enable</ImplicitUsings>
        </PropertyGroup>

        <ItemGroup>
          <PackageReference Include="Microsoft.EntityFrameworkCore" Version="6.0.0" />
          <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="6.0.0">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
          </PackageReference>
          <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="6.0.0" />
          <PackageReference Include="Swashbuckle.AspNetCore" Version="6.2.3" />
        </ItemGroup>

      </Project>

      ```
      </details>

## Creating Models and Controller Actions to enable CRUD functionality.
1. Add Application Model and Entity Context Model: 

    ```
    $ mkdir Models
    $ touch Models/NationalPark.cs 
    $ touch Models/StatePark.cs 
    $ touch Models/ParksApiContext.cs
    ```

    <details><summary><code>Models/NationalPark.cs</code></summary> 

    ```c#
    using System.ComponentModel.DataAnnotations;

    namespace ParksApi.Models
    {
      public class NationalPark
      {
        public int NationalParkId { get; set; }
        public string Name { get; set; }
        public string Location { get; set; }
        public string Description { get; set; }
      }
    }
    ```
    </details>

    <details><summary><code>Models/StatePark.cs</code></summary> 

    ```c#
    using System.ComponentModel.DataAnnotations;

    namespace ParksApi.Models
    {
      public class StatePark
      {
        public int StateParkId { get; set; }
        public string Name { get; set; }
        public string Location { get; set; }
        public string Description { get; set; }
      }
    }
    ```
    </details>

    <details><summary><code>Models/ParksApiContext.cs</code></summary> 
    
    ```c#
    using Microsoft.EntityFrameworkCore;
    
    namespace ParksApi.Models
    {
      public class ParksApiContext : DbContext
      {
        public DbSet<StatePark> StateParks { get; set; }
        public DbSet<NationalPark> NationalParks { get; set; }

        public ParksApiContext(DbContextOptions<ParksApiContext> options) : base(options)
        {
        }
      }
    }
    ```
    </details>

2. Upgrade Program.cs to use MySQL and Context Model

    <details><summary><code>ParksApi/Program.cs</code></summary> 

    ```c#
    using ParksApi.Models;
    using Microsoft.EntityFrameworkCore;
    
    var builder = WebApplication.CreateBuilder(args);
    
    builder.Services.AddControllers();
    
    builder.Services.AddDbContext<ParksApiContext>(
                dbContextOptions => dbContextOptions
                    .UseMySql(
                        builder.Configuration["ConnectionStrings:DefaultConnection"],
                        ServerVersion.AutoDetect(builder.Configuration["ConnectionStrings:DefaultConnection"]
                    )
                )
                );
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();
    
    var app = builder.Build();
    
    if (app.Environment.IsDevelopment())
    
    {
      app.UseSwagger();
      app.UseSwaggerUI();
    }
    else
    {
      app.UseHttpsRedirection();
    }
      
    app.UseHttpsRedirection();
    
    app.UseAuthorization();
    
    app.MapControllers();
    
    app.Run();
    
    ```
    </details>

3. Update appsettings.json with database connection string.
    <details><summary><code>appsettings.json</code></summary> 

    ```json
    {
      "Logging": {
        "LogLevel": {
          "Default": "Information",
          "Microsoft.AspNetCore": "Warning"
        }
      },
      "AllowedHosts": "*",
      "ConnectionStrings": {
        "DefaultConnection": "Server=localhost;Port=3306; database=parks_api;uid=[YOUR-USERNAME-HERE];pwd=  [YOUR-PASSWORD-HERE];"
      }
    }
    ```
    </details>

4. Create initial migration and update database
    ```
    $ dotnet ef migrations add Initial
    $ dotnet ef database update
    ```

5. Use the database context model to seed the database:
    <details><summary><code>Models/ParksApiContext.cs</code></summary> 

    ```c#
    using Microsoft.EntityFrameworkCore;
    
    namespace ParksApi.Models
    {
      public class ParksApiContext : DbContext
      {
        public DbSet<StatePark> StateParks { get; set; }
        public DbSet<NationalPark> NationalParks { get; set; }

        public ParksApiContext(DbContextOptions<ParksApiContext> options) : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            builder.Entity<StatePark>()
                .HasData(
                    new StatePark { StateParkId = 1, Name = "Green Valley State Park", Location = "Arizona", Description = "A beautiful state park with lush greenery." },
                    new StatePark { StateParkId = 2, Name = "Mountain Ridge State Park", Location = "Colorado", Description = "A mountainous state park with breathtaking views." },
                    new StatePark { StateParkId = 3, Name = "Riverfront State Park", Location = "Georgia", Description = "A serene state park along the riverbanks." },
                    new StatePark { StateParkId = 4, Name = "Pine Grove State Park", Location = "Pennsylvania", Description = "A state park surrounded by tall pine trees." }
                );

            builder.Entity<NationalPark>()
                .HasData(
                    new NationalPark { NationalParkId = 1, Name = "Grand Canyon National Park", Location = "Arizona", Description = "A majestic national park known for the Grand Canyon." },
                    new NationalPark { NationalParkId = 2, Name = "Yellowstone National Park", Location = "Wyoming", Description = "The first national park with geothermal wonders." },
                    new NationalPark { NationalParkId = 3, Name = "Great Smoky Mountains National Park", Location = "North Carolina", Description = "A national park with diverse plant and animal life." },
                    new NationalPark { NationalParkId = 4, Name = "Yosemite National Park", Location = "California", Description = "Known for its waterfalls, giant sequoias, and diverse ecosystems." }
                );
        }
      }
    }
    ```
    </details>

     - `$ dotnet ef migrations add SeedData`
     - `$ dotnet ef database update`

6. Add a Controller for your National Park model and complete controller actions for Reading all instances and individual instances of your National Parks Model.
  - `$ touch Controllers/NationalParks.cs`

    <details><summary><code>Controllers/NationalParksController.cs</code></summary>  
    
    ```c#
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;
    using ParksApi.Models;

    namespace ParksApi.Controllers
    {
      [Route("api/[controller]")]
      [ApiController]
      public class NationalParksController : ControllerBase
      {
        private readonly ParksApiContext _db;

        public NationalParksController(ParksApiContext db)
        {
          _db = db;
        }

        // GET api/nationalparks
        [HttpGet]
        public async Task<ActionResult<IEnumerable<NationalPark>>> Get()
        {
          return await _db.NationalParks.ToListAsync();
        }

        // GET: api/NationalParks/{id}
        [HttpGet("{id}")]
        public async Task<ActionResult<NationalPark>> GetNationalPark(int id)
        {
          NationalPark nationalpark = await _db.NationalParks.FindAsync(id);

          if (nationalpark == null)
          {
            return NotFound();
          }

          return nationalpark;
        }
      }
    }
    ```
    </details>

7. Add a Controller for your State Park model and complete controller actions for Reading all instances and individual instances of your State Parks Model.
  - `$ touch Controllers/StateParks.cs`

    <details><summary><code>Controllers/StateParksController.cs</code></summary>  
    
    ```c#
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.EntityFrameworkCore;
    using ParksApi.Models;

    namespace ParksApi.Controllers
    {
      [Route("api/[controller]")]
      [ApiController]
      public class StateParksController : ControllerBase
      {
        private readonly ParksApiContext _db;

        public NationalParksController(ParksApiContext db)
        {
          _db = db;
        }

        // GET api/stateparks
        [HttpGet]
        public async Task<ActionResult<IEnumerable<StatePark>>> Get()
        {
          return await _db.StateParks.ToListAsync();
        }

        // GET: api/StateParks/{id}
        [HttpGet("{id}")]
        public async Task<ActionResult<StatePark>> GetStatePark(int id)
        {
          StatePark Statepark = await _db.StateParks.FindAsync(id);

          if (statepark == null)
          {
            return NotFound();
          }

          return statepark;
        }
      }
    }
    ```
    </details>

8. Test the application to confirm that the new endpoints are functioning correctly. Run the app using the command `$ dotnet run`. In your browser, navigate to [Swagger pages](http://localhost:5000/swagger/index.html) to access the Swagger documentation.

If you are using Postman, perform GET requests on the following endpoints:

- **National Parks:**
  - [`http://localhost:5000/api/NationalParks`](http://localhost:5000/api/NationalParks)
  - [`http://localhost:5000/api/nationalparks/1`](http://localhost:5000/api/nationalparks/1)

- **State Parks:**
  - [`http://localhost:5000/api/StateParks`](http://localhost:5000/api/StateParks)
  - [`http://localhost:5000/api/stateparks/1`](http://localhost:5000/api/stateparks/1)

9. Add a Create action in the National Park controller:
    <details><summary><code>Controllers/NationalParksController.cs</code></summary> 

    ```c#
    ...
    // POST api/nationalparks
    [HttpPost]
    public async Task<ActionResult<NationalPark>> Post(NationalPark nationalpark)
    {
      _db.NationalParks.Add(nationalpark);
      await _db.SaveChangesAsync();
      return CreatedAtAction(nameof(GetNationalPark), new { id = nationalpark.NationalParkId }, nationalpark);
    }
    ...
    ```
    </details>

10. Add an Update action in the National controller:
    <details><summary><code>Controllers/NationalParksController.cs</code></summary> 

    ```c#
    ...
    // PUT: api/NationalParks/{id}
    [HttpPut("{id}")]
    public async Task<IActionResult> Put(int id, NationalPark nationalpark)
    {
      if (id != nationalpark.NationalParkId)
      {
        return BadRequest();
      }

      _db.NationalParks.Update(nationalpark);

      try
      {
        await _db.SaveChangesAsync();
      }
      catch (DbUpdateConcurrencyException)
      {
        if (!NationalParkExists(id))
        {
          return NotFound();
        }
        else
        {
          throw;
        }
      }

      return NoContent();
    }

    // We create this private method so that our controller actions
    // can easily determine whether or not a "nationalpark" exists in the
    // database. Our new Update/Put method needs this!
    private bool NationalParkExists(int id)
    {
      return _db.NationalParks.Any(e => e.NationalParkId == id);
    }
    ...
    ```
    </details>

11. Add an Delete action in the National Park controller:
    <details><summary><code>Controllers/NationalParksController.cs</code></summary> 

    ```c#
    ...
    // DELETE: api/NationalParks/{id}
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteNationalPark(int id)
    {
      NationalPark nationalpark = await _db.NationalParks.FindAsync(id);
      if (nationalpark == null)
      {
        return NotFound();
      }

      _db.NationalParks.Remove(nationalpark);
      await _db.SaveChangesAsync();

      return NoContent();
    }
    ...
    ```
    </details>

12. Add a Create action in the State Park controller:
    <details><summary><code>Controllers/StateParksController.cs</code></summary> 

    ```c#
    ...
    // POST api/stateparks
    [HttpPost]
    public async Task<ActionResult<StatePark>> Post(StatePark statepark)
    {
      _db.StateParks.Add(statepark);
      await _db.SaveChangesAsync();
      return CreatedAtAction(nameof(GetStatePark), new { id = statepark.StateParkId }, statepark);
    }
    ...
    ```
    </details>

11. Add an Update action in the State Parks controller:
    <details><summary><code>Controllers/StateParksController.cs</code></summary> 

    ```c#
    ...
    // PUT: api/StateParks/{id}
    [HttpPut("{id}")]
    public async Task<IActionResult> Put(int id, StatePark statepark)
    {
      if (id != statepark.StateParkId)
      {
        return BadRequest();
      }

      _db.StateParks.Update(statepark);

      try
      {
        await _db.SaveChangesAsync();
      }
      catch (DbUpdateConcurrencyException)
      {
        if (!StateParkExists(id))
        {
          return NotFound();
        }
        else
        {
          throw;
        }
      }

      return NoContent();
    }

    // We create this private method so that our controller actions
    // can easily determine whether or not a "statepark" exists in the
    // database. Our new Update/Put method needs this!
    private bool StateParkExists(int id)
    {
      return _db.StateParks.Any(e => e.StateParkId == id);
    }
    ...
    ```
    </details>

11. Add an Delete action in the State Park controller:
    <details><summary><code>Controllers/StateParksController.cs</code></summary> 

    ```c#
    ...
    // DELETE: api/StateParks/{id}
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteStatePark(int id)
    {
      StatePark statepark = await _db.StateParks.FindAsync(id);
      if (statepark == null)
      {
        return NotFound();
      }

      _db.StateParks.Remove(statepark);
      await _db.SaveChangesAsync();

      return NoContent();
    }
    ...
    ```
    </details>

### Adding Parameters to a GET Request to Support Query Strings for National Parks

- We can add optional parameters for GET rquests so that users can filter results for National Parks. In this example, we'll give users the ability to filter by `name`. The URL for a GET request for all state parks of the location `Green Valley State Park` would look like this: `http://localhost:5000/api/nationalparks?name=Green%20Valley%20State%20Park`.

  - We just need to update our controller's `Get()` action like this:
    <details><summary><code>Controllers/NationalsController.cs</code></summary> 

    ```c#
    ...
    // GET api/nationalparks
    [HttpGet]
    public async Task<List<NationalPark>> Get(string name, string location, string description)
    {
      IQueryable<NationalPark> query = _db.NationalParks.AsQueryable();

      if (name != null)
      {
        query = query.Where(entry => entry.Name == name);
      }

      return await query.ToListAsync();
    }
    ...
    ```
    </details>

  - If we want to handle multiple search parameters we can do so. In this case we add a `location` parameter so users can filter by `name` and `location`:
    <details><summary><code>Controllers/NationalParksController.cs</code></summary> 

    ```c#
    ...
    // GET api/nationalparks
    [HttpGet]
    public async Task<List<NationalPark>> Get(string name, string location, string description)
    {
      IQueryable<NationalPark> query = _db.NationalParks.AsQueryable();

      if (name != null)
      {
        query = query.Where(entry => entry.Name == name);
      }

      if (location != null)
      {
        query = query.Where(entry => entry.Location == location);
      }

      return await query.ToListAsync();
    }
    ...
    ```
    </details>

  - If we want to handle multiple search parameters we can do so. In this case we add a `description` parameter so users can filter by `name`, `location` and `description`:
    <details><summary><code>Controllers/NationalParksController.cs</code></summary> 

    ```c#
    ...
    // GET api/nationalparks
    [HttpGet]
    public async Task<List<NationalPark>> Get(string name, string location, string description)
    {
      IQueryable<NationalPark> query = _db.NationalParks.AsQueryable();

      if (name != null)
      {
        query = query.Where(entry => entry.Name == name);
      }

      if (location != null)
      {
        query = query.Where(entry => entry.Location == location);
      }

      if (description != null)
      {
        query = query.Where(entry => entry.Description == description);
      }

      return await query.ToListAsync();
    }
    ...
    ```
    </details>

  ### Adding Parameters to a GET Request to Support Query Strings for State Parks

- We can add optional parameters for GET rquests so that users can filter results. In this example, we'll give users the ability to filter by `name`. The URL for a GET request for all animals of the species `Grand Canyon National Park` would look like this: `http://localhost:5000/api/stateparks?name=Grand%20Canyon%20National%20Park`.

  - We just need to update our controller's `Get()` action like this:
    <details><summary><code>Controllers/StateParksController.cs</code></summary> 

    ```c#
    ...
    // GET: api/Animals
    [HttpGet]
    public async Task<ActionResult<IEnumerable<StatePark>>> Get(string name)
    {
      IQueryable<StatePark> query = _db.StateParks.AsQueryable();

      if (name != null)
      {
        query = query.Where(entry => entry.Names == names);
      }

      return await query.ToListAsync();
    }
    ...
    ```
    </details>

  - If we want to handle multiple search parameters we can do so. In this case we add a `location` parameter so users can filter by `name` and `location`:
    <details><summary><code>Controllers/StateParksController.cs</code></summary> 

    ```c#
    ...
    // GET api/stateparks
    [HttpGet]
    public async Task<List<StatePark>> Get(string name, string location, string description)
    {
      IQueryable<StatePark> query = _db.StateParks.AsQueryable();

      if (name != null)
      {
        query = query.Where(entry => entry.Name == name);
      }

      if (location != null)
      {
        query = query.Where(entry => entry.Location == location);
      }

      return await query.ToListAsync();
    }
    ...
    ```
    </details>

  - If we want to handle multiple search parameters we can do so. In this case we add a `description` parameter so users can filter by `name`, `location` and `description`:
    <details><summary><code>Controllers/StateParksController.cs</code></summary> 

    ```c#
    ...
    // GET api/state parks
    [HttpGet]
    public async Task<List<StatePark>> Get(string name, string location, string description)
    {
      IQueryable<StatePark> query = _db.StateParks.AsQueryable();

      if (name != null)
      {
        query = query.Where(entry => entry.Name == name);
      }

      if (location != null)
      {
        query = query.Where(entry => entry.Location == location);
      }

      if (description != null)
      {
        query = query.Where(entry => entry.Description == description);
      }

      return await query.ToListAsync();
    }
    ...
    ```
    </details>

### API Model Validations:
-  Model validations in a .NET API work much the same way they do in .NET MVC apps. 
    - `[Required]`: Makes a field required.
    - `[StringLength]`: Determines a maximum length for a string.
    - You can include custom `ErrorMessages` that will be sent back to the user when they send an invalid POST/PUT/PATCH request. If you don't include a custom `ErrorMessage` the API will provide it's own.
    - Always be sure to create a new migration and update the database after every change you make to your models.
    - Here's how we might include them in our National Park model:
      <details><summary><code>Models/NationalPark.cs</code></summary> 

      ```c#
      using System.ComponentModel.DataAnnotations;
      
      namespace ParksApi.Models
      {
        public class NationalPark
        {
        public int NationalParkId { get; set; }
        [Required]
        [StringLength(50)]
        public string Name { get; set; }
        [Required]
        public string Location { get; set; }
        [Required]
        public string Description { get; set; }
        }
      }
      ```
      </details>

      - Here's how we might include them in our State Park model:
      <details><summary><code>Models/StatePark.cs</code></summary> 

      ```c#
      using System.ComponentModel.DataAnnotations;
      
      namespace ParksApi.Models
      {
        public class StatePark
        {
        public int StateParkId { get; set; }
        [Required]
        [StringLength(50)]
        public string Name { get; set; }
        [Required]
        public string Location { get; set; }
        [Required]
        public string Description { get; set; }
        }
      }
      ```
      </details>



